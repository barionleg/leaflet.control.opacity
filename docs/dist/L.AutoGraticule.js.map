{"version":3,"file":"L.AutoGraticule.js","sources":["../src/L.AutoGraticule.ts"],"sourcesContent":["import { LatLngBounds, LatLngExpression, LayerOptions, LeafletEventHandlerFnMap, PolylineOptions, Map, LayerGroup, Util, Polyline, LatLng, marker, divIcon, latLngBounds } from 'leaflet';\nimport './L.AutoGraticule.css';\n\nexport interface AutoGraticuleOptions extends LayerOptions {\n    redraw: keyof LeafletEventHandlerFnMap,\n\n    /** Minimum distance between two lines in pixels */\n    minDistance: number\n}\n\nexport default class AutoGraticule extends LayerGroup {\n\n    options: AutoGraticuleOptions = {\n        redraw: 'moveend',\n        minDistance: 100 // Minimum distance between two lines in pixels\n    };\n\n    lineStyle: PolylineOptions = {\n        stroke: true,\n        color: '#111',\n        opacity: 0.6,\n        weight: 1,\n        interactive: false\n    };\n\n    _bounds!: LatLngBounds;\n\n\n    constructor(options?: Partial<AutoGraticuleOptions>) {\n        super();\n        Util.setOptions(this, options);\n    }\n\n\n    onAdd(map: Map) {\n        this._map = map;\n\n        this.redraw();\n        this._map.on('viewreset ' + this.options.redraw, this.redraw, this);\n\n        this.eachLayer(map.addLayer, map);\n\n        return this;\n    }\n\n    onRemove(map: Map) {\n        map.off('viewreset '+ this.options.redraw, this.redraw, this);\n        this.eachLayer(this.removeLayer, this);\n        return this;\n    }\n\n    redraw() {\n        this._bounds = this._map.getBounds().pad(0.5);\n\n        this.clearLayers();\n\n        this.constructLines();\n\n        return this;\n    }\n\n    constructLines() {\n        const bounds = this._map.getBounds();\n        const zoom = this._map.getZoom();\n\n        // Fix drawing of lines outside of bounds\n        this._bounds = AutoGraticule.bboxIntersect(bounds, [[-85, -180], [85, 180]]);\n\n        // Fix drawing of labels outside of bounds\n        const getBoundsBkp = this._map.getBounds;\n        try {\n            this._map.getBounds = function() {\n                return AutoGraticule.bboxIntersect(getBoundsBkp.apply(this), [[-85, -180], [85, 180]])\n            };\n\n            // Longitude: Draw vartical lines with a fixed distance between each other\n            const center = this._map.project(bounds.getCenter(), zoom);\n            const divisor = AutoGraticule.getGridDivisor(this._map.unproject(center.add([ this.options.minDistance / 2, 0 ]), zoom).lng - this._map.unproject(center.subtract([ this.options.minDistance / 2, 0 ]), zoom).lng, false);\n            const west = Math.max(bounds.getWest(), -180);\n            const east = Math.min(bounds.getEast(), 180);\n            for (let lng = AutoGraticule.fixFloatingPoint(Math.ceil(west/divisor)*divisor); lng <= east; lng+=divisor) {\n                this.addLayer(this.buildXLine(lng));\n                this.addLayer(this.buildLabel('gridlabel-horiz', AutoGraticule.fixFloatingPoint(lng)));\n            }\n\n            // Latitude: Draw horizontal lines with a variable distance between each other (as in Mercator projection, the distance\n            // between latitudes gets bigger towards the poles). Calculate a divisor that all latitude line coordinates must be\n            // dividable by, but then only draw those coordinates that keep the minimum distance to their neighbour lines.\n            // Draw lines north of the equator separately from lines south of the equator (to keep the grid symmetical in\n            // relation to the equator).\n            if(bounds.getNorth() > 0) {\n                let lat = Math.max(0, bounds.getSouth());\n                let first = true;\n                while(lat < bounds.getNorth() && lat < 85) {\n                    const point = this._map.project([ lat, bounds.getCenter().lng ], zoom);\n                    const point2LatLng = this._map.unproject(point.subtract([ 0, this.options.minDistance ]), zoom);\n\n                    const divisor = AutoGraticule.getGridDivisor(point2LatLng.lat - lat, true);\n                    lat = AutoGraticule.fixFloatingPoint(first ? Math.ceil(lat/divisor)*divisor : Math.ceil(point2LatLng.lat/divisor)*divisor);\n\n                    first = false;\n\n                    this.addLayer(this.buildYLine(lat));\n                    this.addLayer(this.buildLabel('gridlabel-vert', lat));\n                }\n            }\n            if(bounds.getSouth() < 0) {\n                let lat = Math.min(0, bounds.getNorth());\n                let first = true;\n                while(lat > bounds.getSouth() && lat > -85) {\n                    const point = this._map.project([ lat, bounds.getCenter().lng ], zoom);\n                    const point2LatLng = this._map.unproject(point.add([ 0, this.options.minDistance ]), zoom);\n\n                    const divisor = AutoGraticule.getGridDivisor(AutoGraticule.fixFloatingPoint(lat - point2LatLng.lat), true);\n                    lat = AutoGraticule.fixFloatingPoint(first ? Math.floor(lat/divisor)*divisor : Math.floor(point2LatLng.lat/divisor)*divisor);\n\n                    first = false;\n\n                    this.addLayer(this.buildYLine(lat));\n                    this.addLayer(this.buildLabel('gridlabel-vert', lat));\n                }\n            }\n        } finally {\n            this._map.getBounds = getBoundsBkp;\n        }\n    }\n\n    buildXLine(x: number): Polyline {\n        const bottomLL = new LatLng(this._bounds.getSouth(), x);\n        const topLL = new LatLng(this._bounds.getNorth(), x);\n\n        return new Polyline([bottomLL, topLL], this.lineStyle);\n    }\n\n    buildYLine(y: number): L.Polyline {\n        const leftLL = new LatLng(y, this._bounds.getWest());\n        const rightLL = new LatLng(y, this._bounds.getEast());\n\n        return new Polyline([leftLL, rightLL], this.lineStyle);\n    }\n\n    buildLabel(axis: 'gridlabel-horiz' | 'gridlabel-vert', val: number) {\n        const bounds = this._map.getBounds().pad(-0.003);\n        let latLng: LatLng;\n        if (axis == 'gridlabel-horiz') {\n            latLng = new LatLng(bounds.getNorth(), val);\n        } else {\n            latLng = new LatLng(val, bounds.getWest());\n        }\n\n        return marker(latLng, {\n            interactive: false,\n            icon: divIcon({\n                iconSize: [0, 0],\n                className: 'leaflet-grid-label',\n                html: '<div class=\"' + axis + '\">' + val + '&#8239;Â°</div>'\n            })\n        });\n    }\n\n    /**\n     * Rounds the given number to a fixed number of decimals in order to avoid floating point inaccuracies\n     * (for example to make 0.1 + 0.2 = 0.3 instead of 0.30000000000000004).\n     */\n    static fixFloatingPoint(number: number): number {\n        return AutoGraticule.round(number, 12);\n    }\n\n    /**\n     * Rounds the given number to the given number of decimals.\n     */\n    static round(number: number, digits: number) {\n        const fac = Math.pow(10, digits);\n        return Math.round(number*fac)/fac;\n    }\n\n    /**\n     * Given the distance between two coordinates, floors this distance to 90, 60, 45, 30 or\n     * 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01, ...\n     * This will define the distance between two grid lines.\n     * @param variableDistance This should be true when the distance between the grid lines will be variable, that is for the latitude\n     *     lines (because in Meractor projection the distance between two latitutes gets larger towards the poles, but the distance\n     *     between two longitudes is constant throughout the globe).\n     *     For constant distance lines (longitude), a line should be shown for every coordinate dividable by the result of this\n     *     function. For example, if the result is 45, a line should be shown for longitudes -180, -135, -90, -45, 0, 45, 90, 135, 180.\n     *     For variable distance lines (latitude), a line should be shown for coordinates dividable by a result of this function, but\n     *     not for every single coordinate but only those that have a minimum distance towards their neighbour coordinate line. For\n     *     variable distance lines, the maximum number returned by this function is 5, meaning at low zoom levels, all latitude lines\n     *     are dividable by 5 (but not every latitude dividable by 5 will get a line).\n     */\n    static getGridDivisor(number: number, variableDistance: boolean) {\n        if(number <= 0 || !isFinite(number))\n            throw new Error(\"Invalid number \" + number);\n        else {\n            if(variableDistance && number >= 5)\n                return 5;\n            if(number <= 10) {\n                let fac = 1;\n                while(number>1) { fac*=10; number/=10; }\n                while(number<=0.1) { fac/=10; number*=10; }\n\n                // Dist is now some number between 0.1 and 1, so we can round it conveniently and then multiply it again by fac to get back to the original dist\n\n                if(number == 0.1)\n                    return AutoGraticule.fixFloatingPoint(0.1*fac);\n                else if(number <= 0.2)\n                    return AutoGraticule.fixFloatingPoint(0.2*fac);\n                else if(number <= 0.5)\n                    return AutoGraticule.fixFloatingPoint(0.5*fac);\n                else\n                    return fac;\n            } else if(number <= 30)\n                return 30;\n            else if(number <= 45)\n                return 45;\n            else if(number <= 60)\n                return 60;\n            else\n                return 90;\n        }\n    }\n    // Backwards compatibility\n    static niceRound = AutoGraticule.getGridDivisor;\n\n    static bboxIntersect(bbox1: LatLngBounds | LatLngExpression[], bbox2: LatLngBounds | LatLngExpression[]) {\n        const bounds1 = bbox1 instanceof LatLngBounds ? bbox1 : latLngBounds(bbox1);\n        const bounds2 = bbox2 instanceof LatLngBounds ? bbox2 : latLngBounds(bbox2);\n        return latLngBounds([\n            [ Math.max(bounds1.getSouth(), bounds2.getSouth()), Math.max(bounds1.getWest(), bounds2.getWest())],\n            [ Math.min(bounds1.getNorth(), bounds2.getNorth()), Math.min(bounds1.getEast(), bounds2.getEast())]\n        ]);\n    }\n}\n"],"names":["divisor"],"mappings":"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"}
